---
title: Problem 10 - Summation of Primes
date: 01/28/26
draft: false
link: <https://projecteuler.net/problem=10>{.link-euler}
image: ../assets/img/DJI_20250430213311_0834_D.jpg
categories: ["primes", "Sieve of Eratosthenes", "summation"]
---

```{r}
#| include: false
#| file: euler/utils/setup.R
```

![ 
  Train tracks leading to Nine Arches Bridge & and surrounding village
  <br>
  Demodara, Ella, Sri Lanka - April 30th, 2025
](../assets/img/DJI_20250430213311_0834_D.jpg)

The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.
<br>
Find the sum of all the primes below two million.

{{< meta link >}}

## Development

## R

### Answer 1 - Trial Division

```{r}
#| cache: true

sieve <- function(n) {
  x <- 2:n
  p <- c()
  while(length(x) > 0) {
    p <- c(p, x[1])
    # incremental elimination
    x <- x[x %% x[1] != 0]
  }
  return(p)
}

tic()
x <- sieve(2e6)
sum(x)
toc()
```

### Answer 2 - {primes} package 

`?primes::generate_primes` tells us that it uses a:

> "a fast implementation of the Sieve of Eratosthenes."

```{r}
#| cache: true

tic()
x <- primes::generate_primes(min = 2, max = 2e6)
sum(x)
toc()
```

This is much faster than [Answer 1](#answer-1---sieve). How can we make our implementation faster?

### Answer 3 - Sieve of Eratosthenes

This idea is ***very*** similar to our implementation, but an order of magnitude more efficient. The Sieve of Eratosthenes does appear to implement an elimination logic, but it is not done by **trial division**.

The `x <- x[x %% x[1] != 0]` line is technically running trial division by the $j^{th}$ prime on every number in the set. However, this is inefficient. 

Instead, multiples of the $j^{th}$ prime starting at $j^2$ can be marked as composite (i.e. ***not** prime). Logically, this gives us the same result at each increment of the loop, but progressively runs an order of magnitude less calculations.

#### 1st Attempt

```{r}
#| cache: true

sieve <- function(n) {
  x <- 2:n
  i <- 1
  while(x[x != 0][i]^2 <= n) {
    x[seq(x[x != 0][i]^2-1, n-1, x[x != 0][i])] <- 0
    i <- i + 1
  }
  return(x[x != 0])
}

tic()
x <- sieve(2e6)
sum(x)
toc()
```

#### 2nd Optimization

This solution can be optimized a bit as well with a `for` loop & then writing a single assignmnet to the non-eliminated prime index (`x != 0`), making less calculations:

```{r}
#| cache: true

sieve <- function(n) {
  x <- 2:n
  for (i in 1:(n-1)) {
    j <- x != 0
    if (x[j][i]^2 > n) {
      return(x[j])
    }
    x[seq(x[j][i]^2-1, n-1, x[j][i])] <- 0
  }
}

tic()
x <- sieve(2e6)
sum(x)
toc()
```

However, this is stil not optimal. We can simply work with primitives (logicals & integers) & loops, not making consecutive index operation calls (e.g. `j <- x!= 0`), and nested calls (e.g. `x[seq(x[j][i]^2-1, n-1, x[j][i])] <- 0`).

#### Optimal

Below is optimized.

```{r}
#| cache: true

sieve <- function(n) {
  # prime candidates
  x <- rep(TRUE, n)
  # number 1 is not prime
  x[1] <- FALSE
  i = 2
  n0 <- floor(sqrt(n))
  for (i in 2:n0) {
    if (x[i]) {
      x[seq(i^2, n, i)] <- FALSE
    }
  }
  return((1:n)[x])
}

tic()
x <- sieve(2e6)
sum(x)
toc()
```

{{< include _0010.qmd >}}
